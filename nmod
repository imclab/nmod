#!/usr/bin/env node
/**
 * It should be installable from the npm database
 * AND from github directly
*/

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//		various utils							//
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

var utils	= {
	progressViewLine	: function(current, total){
		var nbChar	= 40*(current/total);
		process.stdout.write('\r');
		for(var i = 0; i < nbChar; i++)
			process.stdout.write('#');		
	},
	progressViewWheel	: function(current, total){
		var percent	= current/total;
		var chars	= ['|', '/','-', '\\'];
		var charIdx	= Math.floor(percent/0.05) % chars.length;
		var aChar	= chars[charIdx];
		process.stdout.write(aChar+tty_color.cursorBackOne);
	},
	/**
	 * Fetch content of a url
	 *
	 * @param {string} urlStr the url to fetch
	 * @param {Function} dataCb is a function(data){} notified with received data
	 * @param {Function} errorCb is a function(error){} notified when an error occurs
	*/
	fetchUrl	: function(urlStr, dataCb, errorCb){
		dataCb	= dataCb || function(data){}
		errorCb	= errorCb || function(error){}
		var url	= require('url').parse(urlStr);
		var data= "";
		var options = {
			host	: url.hostname,
			port	: (url.port||80),
			path	: url.pathname
		};
		//console.log("fetching", urlStr)
		var req	= require('http').request(options, function(res) {
			var contentLength	= parseInt(res.headers["content-length"], 10)
			//console.log('STATUS: ' + res.statusCode);
			//console.log('HEADERS: ' + JSON.stringify(res.headers));
			res.setEncoding('binary');
			res.on('data', function(chunk){
				//console.log('BODY: ' + chunk);
				data += chunk;
				utils.progressViewWheel(data.length, contentLength)
			});
			res.on('end', function(){
				console.log(" Done")
				dataCb(data);
			});
		});
		req.end();
		req.on('error', errorCb);
	},
	
	/**
	 * like mkdir -p
	 *
	 * - FIXME it doesnt handle the depth. handle the recursive
	*/
	mkdir_pSync	: function(dirname, mode){
		var fs		= require('fs');
		var path	= require('path');
		// normalize dirname
		dirname	= path.resolve(process.cwd(), dirname)
		dirname	= path.normalize(dirname).replace(/\/$/, '');
		var names	= dirname.split('/');
		var fullname	= "";
		names.forEach(function(name, idx){
			var stats	= null;
			fullname	+= (idx != 1 ? '/' : '')+name;
			try {
				stats	= fs.statSync(fullname);
			}catch(e){}
			if( stats && stats.isDirectory() )	return;
			fs.mkdirSync(fullname, mode);
		})
	},

	/**
	 * Do a rm-rf in node
	*/
	rm_rfSync	: function(dirName){
		//console.log("rm_rfSync", dirName)
		var fs		= require('fs')
		var stats	= null;
		try {
			stats	= fs.lstatSync(dirName)			
		}catch(e){
			return;	// silently ignore if the dirName doesnt exist
		}
		if( !stats.isDirectory() ){
			fs.unlinkSync(dirName);
			return
		}
		fs.readdirSync(dirName).forEach(function(basename){
			var fullpath	= require('path').join(dirName, basename);
			utils.rm_rfSync( fullpath )
		})
		fs.rmdirSync(dirName);
	},
	
	/**
	 * return true if the path exist, false otherwiser
	*/
	existSync	: function(path){
		try {
			require('fs').statSync(path);
		}catch(e){
			return false;
		}
		return true;
	},
	
	/**
	*/
	untarData	: function(data, dstDirName, successCb, failureCb){
		successCb	= successCb || function(){};
		failureCb	= failureCb || function(error){console.log("error", error); console.assert(false);}
		var tmpName	= "/tmp/nmod-"+Math.floor(Math.random()*999999).toString(36)+".tgz"
		require('fs').writeFileSync(tmpName, data, "binary")
	
		var cmdArgs	= ["-C", dstDirName, "-zxf", tmpName];
		var spawn	= require('child_process').spawn("tar", cmdArgs);
		spawn.on('exit', function(exitStatus){
			if( exitStatus == 0 )	successCb()
			else			failureCb(exitStatus);
			require('fs').unlinkSync(tmpName);
		})
	},
};

var tty_color	= {};
(function(exports){
	exports.all_off		= "\033[0m";
	exports.bold		= "\033[1m";
	exports.faint   	= "\033[2m"
	exports.cls		= "\033[2J\033[0;0H"
	exports.cursorBackOne	= "\033[1D"
	exports.cursorFrontOne	= "\033[1C"
	exports.fg_green	= "\033[32m"
	exports.fg_red		= "\033[31m"
	exports.bg_green	= "\033[42m"
	exports.bg_red		= "\033[41m"
	exports.img_neg		= "\033[7m"
	exports.img_pos		= "\033[27m"

	var stdoutFd	= 1;
	var isTty	= require('tty').isatty(stdoutFd);

	exports.code	= function(str){
		if(!isTty)	return str;
		return exports.fg_red + str + exports.all_off;
	}
	
})(tty_color);

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//		semver parser							//
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

var semver	= {};
(function(exports){
	// from https://github.com/isaacs/node-semver
	// See http://semver.org/
	// This implementation is a *hair* less strict in that it allows
	// v1.2.3 things, and also tags that don't begin with a char.
	
	var semver = "[v=]*([0-9]+)"                // major
		   + "\\.([0-9]+)"                  // minor
		   + "\\.([0-9]+)"                  // patch
		   + "(-[0-9]+-?)?"                 // build
		   + "([a-zA-Z-][a-zA-Z0-9-\.:]*)?" // tag
	  , exprComparator = "^((<|>)?=?)("+semver+")$|^$"
	  , xRange = "((?:<|>)?=?)([0-9]+|x|X)(?:\\.([0-9]+|x|X)(?:\\.([0-9]+|x|X))?)?"
	  , exprSpermy = "(?:~>?)"+xRange
	  , expressions = exports.expressions =
	    { parse : new RegExp("^\\s*"+semver+"\\s*$")
	    , parsePackage : new RegExp("^\\s*([^\/]+)[-@](" +semver+")\\s*$")
	    , parseRange : new RegExp(
		"^\\s*(" + semver + ")\\s+-\\s+(" + semver + ")\\s*$")
	    , validComparator : new RegExp("^"+exprComparator+"$")
	    , parseXRange : new RegExp("^"+xRange+"$")
	    , parseSpermy : new RegExp("^"+exprSpermy+"$")
	    }
	Object.getOwnPropertyNames(expressions).forEach(function (i) {
	  exports[i] = function (str) { return (str || "").match(expressions[i]) }
	})
	
	exports.rangeReplace = ">=$1 <=$7"
	exports.clean = clean
	exports.compare = compare
	exports.satisfies = satisfies
	exports.gt = gt
	exports.lt = lt
	exports.valid = valid
	exports.validPackage = validPackage
	exports.validRange = validRange
	exports.maxSatisfying = maxSatisfying
	
	function clean (ver) {
	  v = exports.parse(ver)
	  if (!v) return v
	  return [v[1]||'', v[2]||'', v[3]||''].join(".") + (v[4]||'') + (v[5]||'')
	}
	function valid (version) {
	  return exports.parse(version) && version.trim().replace(/^[v=]+/, '')
	}
	function validPackage (version) {
	  return version.match(expressions.parsePackage) && version.trim()
	}
	
	// range can be one of:
	// "1.0.3 - 2.0.0" range, inclusive, like ">=1.0.3 <=2.0.0"
	// ">1.0.2" like 1.0.3 - 9999.9999.9999
	// ">=1.0.2" like 1.0.2 - 9999.9999.9999
	// "<2.0.0" like 0.0.0 - 1.9999.9999
	// ">1.0.2 <2.0.0" like 1.0.3 - 1.9999.9999
	var starExpression = /(<|>)?=?\s*\*/g
	  , starReplace = ""
	  , compTrimExpression = new RegExp("((<|>)?=?)\\s*("+semver+")", "g")
	  , compTrimReplace = "$1$3"
	
	function toComparators (range) {
	  return (range || "").trim()
	    .replace(expressions.parseRange, exports.rangeReplace)
	    .split(/\s+/)
	      .map(replaceSpermies)
	      .map(replaceXRanges)
	    .join(" ")
	    .replace(compTrimExpression, compTrimReplace)
	    .replace(starExpression, starReplace)
	    .split("||")
	    .map(function (orchunk) {
	      return orchunk
		.trim()
		.split(/\s+/)
		.filter(function (c) { return c.match(expressions.validComparator) })
	    })
	    .filter(function (c) { return c.length })
	}
	
	// "2.x","2.x.x" --> ">=2.0.0 <2.1"
	// "2.3.x" --> ">=2.3.0 <2.4.0"
	function replaceXRanges (ranges) {
	  return ranges.split(/\s+/)
		       .map(replaceXRange)
		       .join(" ")
	}
	function replaceXRange (version) {
	  return version.trim().replace(expressions.parseXRange,
					function (v, gtlt, M, m, p) {
	    var anyX = !M || M.toLowerCase() === "x"
		       || !m || m.toLowerCase() === "x"
		       || !p || p.toLowerCase() === "x"
	
	    if (gtlt && anyX) {
	      // just replace x'es with zeroes
	      ;(!M || M.toLowerCase() === "x") && (M = 0)
	      ;(!m || m.toLowerCase() === "x") && (m = 0)
	      ;(!p || p.toLowerCase() === "x") && (p = 0)
	      return gtlt + M+"."+m+"."+p
	    }
	
	    if (!M || M.toLowerCase() === "x") {
	      return "*" // allow any
	    }
	    if (!m || m.toLowerCase() === "x") {
	      return ">="+M+".0.0 <"+(+M+1)+".0.0"
	    }
	    if (!p || p.toLowerCase() === "x") {
	      return ">="+M+"."+m+".0 <"+M+"."+(+m+1)+".0"
	    }
	    return v // impossible?
	  })
	}
	
	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
	function replaceSpermies (version) {
	  return version.trim().replace(expressions.parseSpermy,
					function (v, gtlt, M, m, p) {
	    if (gtlt) throw new Error(
	      "Using '"+gtlt+"' with ~ makes no sense. Don't do it.")
	    if (!M || M.toLowerCase() === "x") {
	      return "*"
	    }
	    if (!m || m.toLowerCase() === "x") {
	      return ">="+M+".0.0 <"+(+M+1)+".0.0"
	    }
	    if (!p || p.toLowerCase() === "x") {
	      return ">="+M+"."+m+".0 <"+M+"."+(+m+1)+".0"
	    }
	    return ">="+M+"."+m+"."+p+" <"+M+"."+(+m+1)+".0"
	  })
	}
	
	function validRange (range) {
	  range = range.trim().replace(starExpression, starReplace)
	  var c = toComparators(range)
	  return (c.length === 0)
	       ? null
	       : c.map(function (c) { return c.join(" ") }).join("||")
	}
	
	// returns the highest satisfying version in the list, or undefined
	function maxSatisfying (versions, range) {
	  return versions
	    .filter(function (v) { return satisfies(v, range) })
	    .sort(compare)
	    .pop()
	}
	function satisfies (version, range) {
	  version = valid(version)
	  if (!version) return false
	  range = toComparators(range)
	  for (var i = 0, l = range.length ; i < l ; i ++) {
	    var ok = false
	    for (var j = 0, ll = range[i].length ; j < ll ; j ++) {
	      var r = range[i][j]
		, gtlt = r.charAt(0) === ">" ? gt
		       : r.charAt(0) === "<" ? lt
		       : false
		, eq = r.charAt(!!gtlt) === "="
		, sub = (!!eq) + (!!gtlt)
	      if (!gtlt) eq = true
	      r = r.substr(sub)
	      r = (r === "") ? r : valid(r)
	      ok = (r === "") || (eq && r === version) || (gtlt && gtlt(version, r))
	      if (!ok) break
	    }
	    if (ok) return true
	  }
	  return false
	}
	
	// return v1 > v2 ? 1 : -1
	function compare (v1, v2) {
	  return v1 === v2 ? 0 : gt(v1, v2) ? 1 : -1
	}
	
	function lt (v1, v2) { return gt(v2, v1) }
	
	// return v1 > v2
	function num (v) {
	  return v === undefined ? -1 : parseInt((v||"0").replace(/[^0-9]+/g, ''), 10)
	}
	function gt (v1, v2) {
	  v1 = exports.parse(v1)
	  v2 = exports.parse(v2)
	  if (!v1 || !v2) return false
	
	  for (var i = 1; i < 5; i ++) {
	    v1[i] = num(v1[i])
	    v2[i] = num(v2[i])
	    if (v1[i] > v2[i]) return true
	    else if (v1[i] !== v2[i]) return false
	  }
	  // no tag is > than any tag, or use lexicographical order.
	  var tag1 = v1[5] || ""
	    , tag2 = v2[5] || ""
	  return !!tag2 && (!tag1 || tag1 > tag2)
	}	
})(semver);

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//		nmod itself							//
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

var nmod	= function(cmdline, cmdopts){
	var ROOTDIR	= cmdopts.rootdir	|| ".";
	/**
	 * Fetch the package.json of the package
	*/
	var getPackageJson	= function(pkgName, pkgVers, successCb, failureCb){
		successCb	= successCb || function(data){};
		failureCb	= failureCb || function(error){console.log("error", error); console.assert(false);}
		var pkgJsonUrl	= "http://registry.npmjs.org/"+pkgName+"/"+pkgVers;
		//console.log("pkgJsonUrl", pkgJsonUrl)
		//console.log("fetching package.json info for", tty_color.code(pkgName+" "+pkgVers));
		process.stdout.write(tty_color.code(pkgName)+": fetching package.json info for version "+pkgVers)
		utils.fetchUrl(pkgJsonUrl, function(dataJson){
			successCb(JSON.parse(dataJson));
		}, function(error){
			failureCb(error);
		})
	}
	/**
	 * Fetch the meta.json of the package
	 *
	 * - http://registry.npmjs.org/{packagename}
	 * - Returns the JSON document for this package. Includes all known dists and metadata
	*/
	var getMetaJson	= function(pkgName, successCb, failureCb){
		successCb	= successCb || function(data){};
		failureCb	= failureCb || function(error){console.log("error", error); console.assert(false);}
		var metaJsonUrl	= "http://registry.npmjs.org/"+pkgName;
		//console.log("metaJsonUrl", metaJsonUrl)
		process.stdout.write(tty_color.code(pkgName)+": fetching meta info...")
		utils.fetchUrl(metaJsonUrl, function(dataJson){
			successCb(JSON.parse(dataJson));
		}, function(error){
			failureCb(error);
		})
	}

	/**
	 * find the pkgVers which match the pkgVersRange for pkgName
	*/
	var findMatchPkgVers	= function(pkgName, pkgVersRange, successCb, failureCb){
		successCb	= successCb || function(pkgVers){};
		failureCb	= failureCb || function(error){console.log("error", error); console.assert(false);}
		getMetaJson(pkgName, function(metaJson){
			var latestVers	= metaJson['dist-tags'].latest;
			if( semver.satisfies(latestVers, pkgVersRange) ){
				successCb(latestVers);
			}else{
				failureCb("no version match");			
			}
		})
	}


	/**
	 * Return the .tar url in the package.json of pkgName/pkgVers
	*/
	var getTarUrl	= function(pkgName, pkgVers, successCb, failureCb){
		successCb	= successCb || function(url){};
		failureCb	= failureCb || function(error){console.log("error", error); console.assert(false);}
		getPackageJson(pkgName, pkgVers, function(data){
			successCb(data.dist.tarball)
		}, function(error){
			failureCb(error)
		})
	}
	
	/**
	 * fetch dependencies in the package.json of pkgName/pkgVers
	*/
	var getDeps	= function(pkgName, pkgVers, successCb, failureCb){
		successCb	= successCb || function(url){};
		failureCb	= failureCb || function(error){console.log("error", error); console.assert(false);}
		getPackageJson(pkgName, pkgVers, function(data){
			successCb(data.dependencies)
		}, function(error){
			failureCb(error)
		})
	}


	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////
	//									//
	//////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////


	/**
	 * List all installed packages in the ROOTDIR
	 *
	 * - NOTE: this command is sync
	*/
	var doCmdLs	= function(){
		var fs		= require('fs');
		var dirname	= ROOTDIR+"/node_modules";
		var basenames	= [];
		try {
			var basenames	= fs.readdirSync(dirname).sort();			
		}catch(e){}
		basenames.forEach(function(basename){
			var fullpath	= dirname+"/"+basename;
			// display this one
			console.log(fullpath);
			// reccurse if needed
			try {
				if( fs.statSync(fullpath).isDirectory() ){
					nmod(["ls"], { rootdir	: fullpath });
				}				
			}catch(e){}
		})
	}

	/**
	 * Uninstall a package
	 *
	 * - note: no version here. as a given pkgName can have a single instance
	 *   in a given node_modules directory
	 * - NOTE: this command is sync
	*/
	var doCmdRm	= function(pkgName){
		var dirname	= ROOTDIR+"/node_modules/"+pkgName;
		process.stdout.write("Remove "+pkgName+" and all deps from "+ROOTDIR+"/node_modules")
		utils.rm_rfSync(dirname)
		process.stdout.write("\n")
	}



	var doCmdInstall	= function(pkgName, pkgVersRange){
		//console.log("pkgName", pkgName, "pkgVersRange", pkgVersRange)

		//console.log("Installing "+pkgName+" in "+ ROOTDIR+"/node_modules")
		
		// display for the user
		process.stdout.write(tty_color.code(pkgName)+": ");
		process.stdout.write(pkgVersRange === ">= 0.0.0"? "latest version": ("version "+pkgVersRange));
		process.stdout.write(" to be installed in "+(ROOTDIR+"/node_modules")+"\n")

		// TODO what if already installed

		findMatchPkgVers(pkgName, pkgVersRange, function(pkgVers){
			var tmpDirname	= ROOTDIR+"/node_modules/.tmp-"+pkgName+"-"+pkgVers;
			var dstDirname	= ROOTDIR+"/node_modules/"+pkgName;
			utils.rm_rfSync(tmpDirname);
			utils.mkdir_pSync(tmpDirname, 0777);
		
			getPackageJson(pkgName, pkgVers, function(pkgJson){
				var tarUrl	= pkgJson.dist.tarball;
				//console.log("tarUrl", tarUrl);
				
				// display for the user
				process.stdout.write(tty_color.code(pkgName)+": ");
				process.stdout.write("fetch .tar data for version "+pkgVers+" ");

				utils.fetchUrl(tarUrl, function(tarData){
					console.log("untar "+tarUrl + " in " + ROOTDIR+"/node_modules")
					utils.untarData(tarData, tmpDirname, function(){
						// get the root directory basename from the package
						var basenames	= require('fs').readdirSync(tmpDirname);
						console.assert(basenames.length === 1)
						//console.log("moving", tmpDirname+"/"+basenames[0], "to", dstDirname)
						// move the untar package from tmpDirname to dstDirname
						require('fs').rename(tmpDirname+"/"+basenames[0], dstDirname);
						// remove tmpDirname
						utils.rm_rfSync(tmpDirname);
						// overwrite the package.json with the one from the server
						// - not sure why it is needed, but ryp is doing it
						// - maybe the package.json is canonized by the server... as isaacs
						require('fs').writeFileSync(dstDirname+"/package.json", JSON.stringify(pkgJson), "binary")
						// compile native extensions if needed
						if( utils.existSync(dstDirname+"wscript") ){
							//  ( cd ./node_modules/$pkg &>/dev/null; node-waf configure build )
							console.assert(false, "not yet implemented")
						}
						// install the dependancies 
						nmod(["deps"], { rootdir : dstDirname });
					})
				})
			});
		});
	}

	/**
	 * Install dependencies from package.json file.
	*/
	var doCmdDeps	= function(){
		var filename	= ROOTDIR+"/package.json";
		console.log("installing dependancies from "+filename);
		try {
			var dataJson	= require('fs').readFileSync(filename);			
		}catch(e){
			console.log("nmod deps: skipped : no ./package.json")
			return;
		}
		var data	= JSON.parse(dataJson);
		var deps	= data.dependencies	|| {};
		Object.keys(deps).forEach(function(pkgName){
			var pkgVersRange	= data.dependencies[pkgName];
			//console.log("pkgName", pkgName, "pkgVers", pkgVersRange)
			console.log("Install dependancy "+pkgName+"("+pkgVersRange+") in "+ROOTDIR)
			// install the dependancies 
			nmod(["install", pkgName, pkgVersRange], { rootdir : ROOTDIR });			
		})
	}


	var parseCmdline	= function(argv){
		// define aliases
		var aliases	= {
			list		: "ls",
			remove		: "rm",
			uninstall	: "rm"
		}
		// honor aliases
		if( aliases[argv[0]] )	argv[0]	= aliases[argv[0]];
		// handle each command
		if( argv[0] == "ls"){
			return doCmdLs();
		}else if( argv[0] == "install" ){
			console.assert( argv.length == 2 || argv.length == 3);
			return doCmdInstall(argv[1], argv[2] || ">= 0.0.0");
		}else if( argv[0] == "deps" ){
			console.assert( argv.length == 1 );
			return doCmdDeps();
		}else if( argv[0] == "rm" ){
			console.assert( argv.length == 2 )
			return doCmdRm(argv[1]);
		}else if( argv.length == 0 || argv[0] == "help"){
			console.log("nmod: install node_modules from npm or git")
			console.log("nmod install <package> - Install a package, and nest its deps.");
			console.log("nmod ls                - Show installed packages.");
			console.log("nmod rm <package>      - Remove a package");
			console.log("nmod deps              - Install dependencies from package.json file");
		}else{
			console.log("Command "+argv[0]+" is unknown")
		}
		return undefined;
	}
	
	parseCmdline(cmdline)

	/**
	 * Return public methods
	*/
	return {
		// TODO should i put something in there ?	
	}
}

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//		main program							//
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

/**
*/
//nmod(["ls"], {	rootdir	: "/tmp/slota" })
//nmod(["install", "underscore"], {	rootdir	: "/tmp/bla" })
//nmod(["deps"], {	rootdir	: "/tmp/slota/node_modules/connect" })

//utils.rm_rfSync("/tmp/bla/node_modules")
//nmod(["install", "qs", ">= 0.0.6"], {	rootdir	: "/tmp/bla" })
//nmod(["install", "express"], {	rootdir	: "/tmp/bla" })

//utils.mkdir_pSync("/tmp/slota/wow", 0777)
//utils.rm_rfSync("/tmp/bla/node_modules")

var ROOTDIR	= process.env["nmod_ROOT"]	|| '.';
nmod(process.argv.slice(2), {rootdir: ROOTDIR})







